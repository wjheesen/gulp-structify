// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
import {Struct} from "gulp-structify/struct";
import {StructBuffer} from "gulp-structify/buffer";
import {applyMixins} from "gulp-structify/mixin";

/**
 * An 8-bit (r,g,b,a) color.
 */
export class Color {
    static random() {
        let color = new Color();
        color.setRandom();
        return color;
    }

    static fromArgbString(argb: string) {
        let color = new Color();
        color.setFromArgbString(argb);
        return color;
    }

    static fromRgbaInt(rgba: number) {
        let color = new Color();
        color.setFromRgbaInt(rgba);
        return color;
    }

    static create(other: ColorLike) {
        let color = new Color();
        color.set(other);
        return color;
    }

    /**
     * The red component of this Color.
     */
    r: number;
    /**
     * The green component of this Color.
     */
    g: number;
    /**
     * The blue component of this Color.
     */
    b: number;
    /**
     * The alpha component of this Color.
     */
    a: number;

    /**
     * An 8-bit (r,g,b,a) color.
     */
    constructor(r = 0, g = 0, b = 0, a = 0) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }

    /**
     * Checks if this Color is fully opaque. 
     */
    isOpaque() {
        return this.a === 0xff;
    }

    /**
     * Checks if this Color is fully transparent.
     */
    isTransparent() {
        return this.a === 0;
    }

    /**
     * Randomly sets the (r,g,b) components of this color.
     */
    setRandom() {
        this.r = randomInt(0, 0xff);
        this.g = randomInt(0, 0xff);
        this.b = randomInt(0, 0xff);
    }

    /**
     * Extracts the (r,g,b,a) components of the specified ARGB string into this Color.
     * @param argb hexadecimal string of the form #aarrggbb.
     */
    setFromArgbString(argb: string) {
        let result = ArgbRegex.exec(argb);
        this.a = parseInt(result[1], 16);
        this.r = parseInt(result[2], 16);
        this.g = parseInt(result[3], 16);
        this.b = parseInt(result[4], 16);
    }

    /**
     * Creates an ARGB string from this Color's (r,g,b,a) components.
     * @returns string of the form #aarrggbb
     */
    toArgbString(this: Color) {
        let r = pad(this.r.toString(16));
        let g = pad(this.g.toString(16));
        let b = pad(this.b.toString(16));
        let a = pad(this.a.toString(16));
        return '#' + a + r + g + b;
    }

    /**
     * Extracts the (r,g,b,a) components of the specified RGBA int into this color.
     * @param rgba integer of the form 0xrrggbbaa.
     */
    setFromRgbaInt(rgba: number) {
        this.r = (rgba >> 24) & 0xff;
        this.g = (rgba >> 16) & 0xff;
        this.b = (rgba >> 8) & 0xff;
        this.a = (rgba >> 0) & 0xff;
    }

    /**
     * Creates an RGBA int with this Color's (r,g,b,a) components.
     * @returns int of the form 0xrrggbbaa
     */
    toRgbaInt() {
        let r = this.r << 24;
        let g = this.g << 16;
        let b = this.b << 8;
        let a = this.a << 0;
        return (r | g | b | a) >>> 0;
    }

    /**
     * Blends the source color into this color using (src.alpha, 1-src.alpha) blend mode.
     */
    blend(src: Color) {
        let alpha = src.a + 1, invAlpha = 256 - src.a;
        this.r = (alpha * src.r + invAlpha * this.r) >> 8;
        this.g = (alpha * src.g + invAlpha * this.g) >> 8;
        this.b = (alpha * src.b + invAlpha * this.b) >> 8;
    }

    /**
     * Sets each component of this Color to that of the other Color.
     */
    set(other: ColorLike) {
        this.r = other.r;
        this.g = other.g;
        this.b = other.b;
        this.a = other.a;
    }

    /**
     * Sets each component of this Color.
     */
    set$(r: number, g: number, b: number, a: number) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }

    /**
     * Sets each component of this Color to the specified scalar.
     */
    setScalar(k: number) {
        this.r = k;
        this.g = k;
        this.b = k;
        this.a = k;
    }

    /**
     * Adds the other Color to this Color componentwise.
     */
    add(other: ColorLike) {
        this.r += other.r;
        this.g += other.g;
        this.b += other.b;
        this.a += other.a;
    }

    /**
     * Adds the specified values to this Color componentwise.
     */
    add$(r: number, g: number, b: number, a: number) {
        this.r += r;
        this.g += g;
        this.b += b;
        this.a += a;
    }

    /**
     * Subtracts the other Color from this Color componentwise.
     */
    subtract(other: ColorLike) {
        this.r -= other.r;
        this.g -= other.g;
        this.b -= other.b;
        this.a -= other.a;
    }

    /**
     * Subtracts the specified values from this Color componentwise.
     */
    subtract$(r: number, g: number, b: number, a: number) {
        this.r -= r;
        this.g -= g;
        this.b -= b;
        this.a -= a;
    }

    /**
     * Multiplies each component of this Color by the specified scalar.
     */
    mulScalar(k: number) {
        this.r *= k;
        this.g *= k;
        this.b *= k;
        this.a *= k;
    }

    /**
     * Divides each component of this Color by the specified scalar.
     */
    divScalar(k: number) {
        this.r /= k;
        this.g /= k;
        this.b /= k;
        this.a /= k;
    }

    /**
     * Checks if each component of this Color is exactly equal to that of the other Color.
     */
    equals(other: ColorLike) {
        return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
    }

    /**
     * Checks if each component of this Color is exactly equal to the specified scalar.
     */
    equalsScalar(k: number) {
        return this.r === k && this.g === k && this.b === k && this.a === k;
    }

    /**
     * Checks if each component of this Color is approximately equal to that of the other Color.
     */
    epsilonEquals(other: ColorLike, e: number) {
        return Math.abs(this.r - other.r) <= e && Math.abs(this.g - other.g) <= e && Math.abs(this.b - other.b) <= e && Math.abs(this.a - other.a) <= e;
    }

    /**
     * Checks if each component of this Color is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar(k: number, e: number) {
        return Math.abs(this.r - k) <= e && Math.abs(this.g - k) <= e && Math.abs(this.b - k) <= e && Math.abs(this.a - k) <= e;
    }

    /**
     * Returns a string representation of this Color.
     */
    toString() {
        return `{ r: ${this.r}, g: ${this.g}, b: ${this.b}, a: ${this.a} }`
    }
}

const ArgbRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;

function pad(str: string) {
    return (str.length == 1) ? '0' + str : str;
}

/**
 * Returns a random integer between min (inclusive) and max (inclusive)
 */
function randomInt(min: number, max: number) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * An 8-bit (r,g,b,a) color.
 */
export interface ColorLike {
    /**
     * The red component of this Color.
     */
    r: number;
    /**
     * The green component of this Color.
     */
    g: number;
    /**
     * The blue component of this Color.
     */
    b: number;
    /**
     * The alpha component of this Color.
     */
    a: number;
}

/**
 * A Color backed by a Uint8Array.
 */
export class ColorStruct extends Struct<Uint8Array> {
    static random() {
        let color = new ColorStruct();
        color.setRandom();
        return color;
    }

    static fromArgbString(argb: string) {
        let color = new ColorStruct();
        color.setFromArgbString(argb);
        return color;
    }

    static fromRgbaInt(rgba: number) {
        let color = new ColorStruct();
        color.setFromRgbaInt(rgba);
        return color;
    }

    static create(other: ColorLike) {
        let color = new ColorStruct();
        color.set(other);
        return color;
    }

    static create$(r: number, g: number, b: number, a: number) {
        let color = new ColorStruct();
        color.set$(r, g, b, a);
        return color;
    }

    /**
     * Checks if this Color is fully opaque. 
     */
    isOpaque: () => boolean;
    /**
     * Checks if this Color is fully transparent.
     */
    isTransparent: () => boolean;
    /**
     * Randomly sets the (r,g,b) components of this color.
     */
    setRandom: () => void;
    /**
     * Extracts the (r,g,b,a) components of the specified ARGB string into this Color.
     * @param argb hexadecimal string of the form #aarrggbb.
     */
    setFromArgbString: (argb: string) => void;
    /**
     * Creates an ARGB string from this Color's (r,g,b,a) components.
     * @returns string of the form #aarrggbb
     */
    toArgbString: () => string;
    /**
     * Extracts the (r,g,b,a) components of the specified RGBA int into this color.
     * @param rgba integer of the form 0xrrggbbaa.
     */
    setFromRgbaInt: (rgba: number) => void;
    /**
     * Creates an RGBA int with this Color's (r,g,b,a) components.
     * @returns int of the form 0xrrggbbaa
     */
    toRgbaInt: () => number;
    /**
     * Blends the source color into this color using (src.alpha, 1-src.alpha) blend mode.
     */
    blend: (src: Color) => void;
    /**
     * Sets each component of this Color to that of the other Color.
     */
    set: (other: ColorLike) => void;
    /**
     * Sets each component of this Color.
     */
    set$: (r: number, g: number, b: number, a: number) => void;
    /**
     * Sets each component of this Color to the specified scalar.
     */
    setScalar: (k: number) => void;
    /**
     * Adds the other Color to this Color componentwise.
     */
    add: (other: ColorLike) => void;
    /**
     * Adds the specified values to this Color componentwise.
     */
    add$: (r: number, g: number, b: number, a: number) => void;
    /**
     * Subtracts the other Color from this Color componentwise.
     */
    subtract: (other: ColorLike) => void;
    /**
     * Subtracts the specified values from this Color componentwise.
     */
    subtract$: (r: number, g: number, b: number, a: number) => void;
    /**
     * Multiplies each component of this Color by the specified scalar.
     */
    mulScalar: (k: number) => void;
    /**
     * Divides each component of this Color by the specified scalar.
     */
    divScalar: (k: number) => void;
    /**
     * Checks if each component of this Color is exactly equal to that of the other Color.
     */
    equals: (other: ColorLike) => boolean;
    /**
     * Checks if each component of this Color is exactly equal to the specified scalar.
     */
    equalsScalar: (k: number) => boolean;
    /**
     * Checks if each component of this Color is approximately equal to that of the other Color.
     */
    epsilonEquals: (other: ColorLike, e: number) => boolean;
    /**
     * Checks if each component of this Color is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar: (k: number, e: number) => boolean;
    /**
     * Returns a string representation of this Color.
     */
    toString: () => string;

    /**
     * Creates a Color struct backed by the specified data.
     */
    constructor(data = new Uint8Array(4)) {
        super(data);
    }

    /**
     * The red component of this Color.
     */
    get r() {
        return this.data[0];
    }

    /**
     * The red component of this Color.
     */
    set r(value: number) {
        this.data[0] = value;
    }

    /**
     * The green component of this Color.
     */
    get g() {
        return this.data[1];
    }

    /**
     * The green component of this Color.
     */
    set g(value: number) {
        this.data[1] = value;
    }

    /**
     * The blue component of this Color.
     */
    get b() {
        return this.data[2];
    }

    /**
     * The blue component of this Color.
     */
    set b(value: number) {
        this.data[2] = value;
    }

    /**
     * The alpha component of this Color.
     */
    get a() {
        return this.data[3];
    }

    /**
     * The alpha component of this Color.
     */
    set a(value: number) {
        this.data[3] = value;
    }
}

applyMixins(ColorStruct, Color);
/**
 * A Color buffer backed by a Uint8Array.
 */
export class ColorBuffer extends StructBuffer<Uint8Array> {
    /**
     * Creates an empty Color buffer with the specified Color capacity.
     */
    static create(capacity: number) {
        return new ColorBuffer(new Uint8Array(capacity * 4));
    }

    /**
     * Checks if this Color is fully opaque. 
     */
    isOpaque: () => boolean;
    /**
     * Checks if this Color is fully transparent.
     */
    isTransparent: () => boolean;
    /**
     * Randomly sets the (r,g,b) components of this color.
     */
    setRandom: () => void;
    /**
     * Extracts the (r,g,b,a) components of the specified ARGB string into this Color.
     * @param argb hexadecimal string of the form #aarrggbb.
     */
    setFromArgbString: (argb: string) => void;
    /**
     * Creates an ARGB string from this Color's (r,g,b,a) components.
     * @returns string of the form #aarrggbb
     */
    toArgbString: () => string;
    /**
     * Extracts the (r,g,b,a) components of the specified RGBA int into this color.
     * @param rgba integer of the form 0xrrggbbaa.
     */
    setFromRgbaInt: (rgba: number) => void;
    /**
     * Creates an RGBA int with this Color's (r,g,b,a) components.
     * @returns int of the form 0xrrggbbaa
     */
    toRgbaInt: () => number;
    /**
     * Blends the source color into this color using (src.alpha, 1-src.alpha) blend mode.
     */
    blend: (src: Color) => void;
    /**
     * Sets each component of this Color to that of the other Color.
     */
    set: (other: ColorLike) => void;
    /**
     * Sets each component of this Color.
     */
    set$: (r: number, g: number, b: number, a: number) => void;
    /**
     * Sets each component of this Color to the specified scalar.
     */
    setScalar: (k: number) => void;
    /**
     * Adds the other Color to this Color componentwise.
     */
    add: (other: ColorLike) => void;
    /**
     * Adds the specified values to this Color componentwise.
     */
    add$: (r: number, g: number, b: number, a: number) => void;
    /**
     * Subtracts the other Color from this Color componentwise.
     */
    subtract: (other: ColorLike) => void;
    /**
     * Subtracts the specified values from this Color componentwise.
     */
    subtract$: (r: number, g: number, b: number, a: number) => void;
    /**
     * Multiplies each component of this Color by the specified scalar.
     */
    mulScalar: (k: number) => void;
    /**
     * Divides each component of this Color by the specified scalar.
     */
    divScalar: (k: number) => void;
    /**
     * Checks if each component of this Color is exactly equal to that of the other Color.
     */
    equals: (other: ColorLike) => boolean;
    /**
     * Checks if each component of this Color is exactly equal to the specified scalar.
     */
    equalsScalar: (k: number) => boolean;
    /**
     * Checks if each component of this Color is approximately equal to that of the other Color.
     */
    epsilonEquals: (other: ColorLike, e: number) => boolean;
    /**
     * Checks if each component of this Color is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar: (k: number, e: number) => boolean;
    /**
     * Returns a string representation of this Color.
     */
    toString: () => string;

    /**
     * The red component of the current Color.
     */
    get r() {
        return this.data[this.dataPosition + 0];
    }

    /**
     * The red component of the current Color.
     */
    set r(value: number) {
        this.data[this.dataPosition + 0] = value;
    }

    /**
     * The green component of the current Color.
     */
    get g() {
        return this.data[this.dataPosition + 1];
    }

    /**
     * The green component of the current Color.
     */
    set g(value: number) {
        this.data[this.dataPosition + 1] = value;
    }

    /**
     * The blue component of the current Color.
     */
    get b() {
        return this.data[this.dataPosition + 2];
    }

    /**
     * The blue component of the current Color.
     */
    set b(value: number) {
        this.data[this.dataPosition + 2] = value;
    }

    /**
     * The alpha component of the current Color.
     */
    get a() {
        return this.data[this.dataPosition + 3];
    }

    /**
     * The alpha component of the current Color.
     */
    set a(value: number) {
        this.data[this.dataPosition + 3] = value;
    }

    /**
     * Gets the number of properties in a Color, namely 4.
     */
    structLength() {
        return 4;
    }

    /**
     * Gets the components of the Color at the specified position of this buffer.
     */
    aget(position: number, dst?: ColorLike) {
        if (dst === void 0){ dst = new Color()};
        let dataPos = position * this.structLength();
        dst.r = this.data[dataPos++];
        dst.g = this.data[dataPos++];
        dst.b = this.data[dataPos++];
        dst.a = this.data[dataPos++];
        return dst;
    }

    /**
     * Gets the components of the current Color, then moves to the next position of this buffer.
     */
    rget(position: number, dst?: ColorLike) {
        if (dst === void 0){ dst = new Color()};
        dst.r = this.data[this.dataPosition++];
        dst.g = this.data[this.dataPosition++];
        dst.b = this.data[this.dataPosition++];
        dst.a = this.data[this.dataPosition++];
        return dst;
    }

    /**
     * Sets each component of the Color at the specified position to that of the src Color.
     */
    aset(position: number, src: ColorLike) {
        let dataPos = position * this.structLength();
        this.data[dataPos++] = src.r;
        this.data[dataPos++] = src.g;
        this.data[dataPos++] = src.b;
        this.data[dataPos++] = src.a;
    }

    /**
     * Sets each component of the Color at the specified position.
     */
    aset$(position: number, r: number, g: number, b: number, a: number) {
        let dataPos = position * this.structLength();
        this.data[dataPos++] = r;
        this.data[dataPos++] = g;
        this.data[dataPos++] = b;
        this.data[dataPos++] = a;
    }

    /**
     * Sets each component of the current Color to that of the src Color, then moves to the next position of this buffer.
     */
    rset(src: ColorLike) {
        this.data[this.dataPosition++] = src.r;
        this.data[this.dataPosition++] = src.g;
        this.data[this.dataPosition++] = src.b;
        this.data[this.dataPosition++] = src.a;
    }

    /**
     * Sets each component of the current Color, then moves to the next position of this buffer.
     */
    rset$(r: number, g: number, b: number, a: number) {
        this.data[this.dataPosition++] = r;
        this.data[this.dataPosition++] = g;
        this.data[this.dataPosition++] = b;
        this.data[this.dataPosition++] = a;
    }
}

applyMixins(ColorBuffer, Color);
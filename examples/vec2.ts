// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
import {Point} from "./point";
import {Struct} from "gulp-structify/struct";
import {StructBuffer} from "gulp-structify/buffer";
import {applyMixins} from "gulp-structify/mixin";

/**
 * A two-dimensional vector with (x,y) components.
 */
export class Vec2 {
    static fromPointToPoint(initial: Point, terminal: Point) {
        let vec2 = new Vec2();
        vec2.setFromPointToPoint(initial, terminal);
        return vec2;
    }

    static create(other: Vec2Like) {
        let vec2 = new Vec2();
        vec2.set(other);
        return vec2;
    }

    /**
     * The X component of this Vec2.
     */
    x: number;
    /**
     * The Y component of this Vec2.
     */
    y: number;

    /**
     * A two-dimensional vector with (x,y) components.
     */
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    /**
     * Computes the length of this Vec2.
     */
    length() {
        return Math.sqrt(this.length2());
    }

    /**
     * Computes the length squared of this Vec2.
     */
    length2() {
        return this.x * this.x + this.y * this.y;
    }

    /**
     * Sets this Vec2 to a vector from the initial point to the terminal point. 
     */
    setFromPointToPoint(initial: Point, terminal: Point) {
        this.x = terminal.x - initial.x;
        this.y = terminal.y - initial.y;
    }

    /**
     * Computes the dot product of this Vec2 with the other Vec2.
     */
    dot(other: Vec2Like) {
        return this.x * other.x + this.y * other.y;
    }

    /**
     * Computes the cross product of this Vec2 with the other Vec2.
     */
    cross(other: Vec2Like) {
        return (this.x * other.y) - (other.x * this.y);
    }

    /**
     * Normalizes this Vec2 so that it has a length of one.
     */
    normalize() {
        this.divScalar(this.length());
    }

    /**
     * Rotates this Vec2 90 degrees to the left (CCW).
     */
    rotateLeft() {
        let x = this.x;
        this.x = -this.y;
        this.y = x;
    }

    /**
     * Rotates this Vec2 90 degrees to the right (CW).
     */
    rotateRight() {
        let x = this.x;
        this.x = this.y;
        this.y = -x;
    }

    /**
     * Sets each component of this Vec2 to that of the other Vec2.
     */
    set(other: Vec2Like) {
        this.x = other.x;
        this.y = other.y;
    }

    /**
     * Sets each component of this Vec2.
     */
    set$(x: number, y: number) {
        this.x = x;
        this.y = y;
    }

    /**
     * Sets each component of this Vec2 to the specified scalar.
     */
    setScalar(k: number) {
        this.x = k;
        this.y = k;
    }

    /**
     * Adds the other Vec2 to this Vec2 componentwise.
     */
    add(other: Vec2Like) {
        this.x += other.x;
        this.y += other.y;
    }

    /**
     * Adds the specified values to this Vec2 componentwise.
     */
    add$(x: number, y: number) {
        this.x += x;
        this.y += y;
    }

    /**
     * Subtracts the other Vec2 from this Vec2 componentwise.
     */
    subtract(other: Vec2Like) {
        this.x -= other.x;
        this.y -= other.y;
    }

    /**
     * Subtracts the specified values from this Vec2 componentwise.
     */
    subtract$(x: number, y: number) {
        this.x -= x;
        this.y -= y;
    }

    /**
     * Multiplies each component of this Vec2 by the specified scalar.
     */
    mulScalar(k: number) {
        this.x *= k;
        this.y *= k;
    }

    /**
     * Divides each component of this Vec2 by the specified scalar.
     */
    divScalar(k: number) {
        this.x /= k;
        this.y /= k;
    }

    /**
     * Checks if each component of this Vec2 is exactly equal to that of the other Vec2.
     */
    equals(other: Vec2Like) {
        return this.x === other.x && this.y === other.y;
    }

    /**
     * Checks if each component of this Vec2 is exactly equal to the specified scalar.
     */
    equalsScalar(k: number) {
        return this.x === k && this.y === k;
    }

    /**
     * Checks if each component of this Vec2 is approximately equal to that of the other Vec2.
     */
    epsilonEquals(other: Vec2Like, e: number) {
        return Math.abs(this.x - other.x) <= e && Math.abs(this.y - other.y) <= e;
    }

    /**
     * Checks if each component of this Vec2 is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar(k: number, e: number) {
        return Math.abs(this.x - k) <= e && Math.abs(this.y - k) <= e;
    }

    /**
     * Returns a string representation of this Vec2.
     */
    toString() {
        return `{ x: ${this.x}, y: ${this.y} }`
    }
}

/**
 * A two-dimensional vector with (x,y) components.
 */
export interface Vec2Like {
    /**
     * The X component of this Vec2.
     */
    x: number;
    /**
     * The Y component of this Vec2.
     */
    y: number;
}

/**
 * A Vec2 backed by a Float32Array.
 */
export class Vec2Struct extends Struct<Float32Array> {
    static fromPointToPoint(initial: Point, terminal: Point) {
        let vec2 = new Vec2Struct();
        vec2.setFromPointToPoint(initial, terminal);
        return vec2;
    }

    static create(other: Vec2Like) {
        let vec2 = new Vec2Struct();
        vec2.set(other);
        return vec2;
    }

    static create$(x: number, y: number) {
        let vec2 = new Vec2Struct();
        vec2.set$(x, y);
        return vec2;
    }

    /**
     * Computes the length of this Vec2.
     */
    length: () => number;
    /**
     * Computes the length squared of this Vec2.
     */
    length2: () => number;
    /**
     * Sets this Vec2 to a vector from the initial point to the terminal point. 
     */
    setFromPointToPoint: (initial: Point, terminal: Point) => void;
    /**
     * Computes the dot product of this Vec2 with the other Vec2.
     */
    dot: (other: Vec2Like) => number;
    /**
     * Computes the cross product of this Vec2 with the other Vec2.
     */
    cross: (other: Vec2Like) => number;
    /**
     * Normalizes this Vec2 so that it has a length of one.
     */
    normalize: () => void;
    /**
     * Rotates this Vec2 90 degrees to the left (CCW).
     */
    rotateLeft: () => void;
    /**
     * Rotates this Vec2 90 degrees to the right (CW).
     */
    rotateRight: () => void;
    /**
     * Sets each component of this Vec2 to that of the other Vec2.
     */
    set: (other: Vec2Like) => void;
    /**
     * Sets each component of this Vec2.
     */
    set$: (x: number, y: number) => void;
    /**
     * Sets each component of this Vec2 to the specified scalar.
     */
    setScalar: (k: number) => void;
    /**
     * Adds the other Vec2 to this Vec2 componentwise.
     */
    add: (other: Vec2Like) => void;
    /**
     * Adds the specified values to this Vec2 componentwise.
     */
    add$: (x: number, y: number) => void;
    /**
     * Subtracts the other Vec2 from this Vec2 componentwise.
     */
    subtract: (other: Vec2Like) => void;
    /**
     * Subtracts the specified values from this Vec2 componentwise.
     */
    subtract$: (x: number, y: number) => void;
    /**
     * Multiplies each component of this Vec2 by the specified scalar.
     */
    mulScalar: (k: number) => void;
    /**
     * Divides each component of this Vec2 by the specified scalar.
     */
    divScalar: (k: number) => void;
    /**
     * Checks if each component of this Vec2 is exactly equal to that of the other Vec2.
     */
    equals: (other: Vec2Like) => boolean;
    /**
     * Checks if each component of this Vec2 is exactly equal to the specified scalar.
     */
    equalsScalar: (k: number) => boolean;
    /**
     * Checks if each component of this Vec2 is approximately equal to that of the other Vec2.
     */
    epsilonEquals: (other: Vec2Like, e: number) => boolean;
    /**
     * Checks if each component of this Vec2 is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar: (k: number, e: number) => boolean;
    /**
     * Returns a string representation of this Vec2.
     */
    toString: () => string;

    /**
     * Creates a Vec2 struct backed by the specified data.
     */
    constructor(data = new Float32Array(2)) {
        super(data);
    }

    /**
     * The X component of this Vec2.
     */
    get x() {
        return this.data[0];
    }

    /**
     * The X component of this Vec2.
     */
    set x(value: number) {
        this.data[0] = value;
    }

    /**
     * The Y component of this Vec2.
     */
    get y() {
        return this.data[1];
    }

    /**
     * The Y component of this Vec2.
     */
    set y(value: number) {
        this.data[1] = value;
    }
}

applyMixins(Vec2Struct, Vec2);
/**
 * A Vec2 buffer backed by a Float32Array.
 */
export class Vec2Buffer extends StructBuffer<Float32Array> {
    /**
     * Creates an empty Vec2 buffer with the specified Vec2 capacity.
     */
    static create(capacity: number) {
        return new Vec2Buffer(new Float32Array(capacity * 2));
    }

    /**
     * Computes the length of this Vec2.
     */
    length: () => number;
    /**
     * Computes the length squared of this Vec2.
     */
    length2: () => number;
    /**
     * Sets this Vec2 to a vector from the initial point to the terminal point. 
     */
    setFromPointToPoint: (initial: Point, terminal: Point) => void;
    /**
     * Computes the dot product of this Vec2 with the other Vec2.
     */
    dot: (other: Vec2Like) => number;
    /**
     * Computes the cross product of this Vec2 with the other Vec2.
     */
    cross: (other: Vec2Like) => number;
    /**
     * Normalizes this Vec2 so that it has a length of one.
     */
    normalize: () => void;
    /**
     * Rotates this Vec2 90 degrees to the left (CCW).
     */
    rotateLeft: () => void;
    /**
     * Rotates this Vec2 90 degrees to the right (CW).
     */
    rotateRight: () => void;
    /**
     * Sets each component of this Vec2 to that of the other Vec2.
     */
    set: (other: Vec2Like) => void;
    /**
     * Sets each component of this Vec2.
     */
    set$: (x: number, y: number) => void;
    /**
     * Sets each component of this Vec2 to the specified scalar.
     */
    setScalar: (k: number) => void;
    /**
     * Adds the other Vec2 to this Vec2 componentwise.
     */
    add: (other: Vec2Like) => void;
    /**
     * Adds the specified values to this Vec2 componentwise.
     */
    add$: (x: number, y: number) => void;
    /**
     * Subtracts the other Vec2 from this Vec2 componentwise.
     */
    subtract: (other: Vec2Like) => void;
    /**
     * Subtracts the specified values from this Vec2 componentwise.
     */
    subtract$: (x: number, y: number) => void;
    /**
     * Multiplies each component of this Vec2 by the specified scalar.
     */
    mulScalar: (k: number) => void;
    /**
     * Divides each component of this Vec2 by the specified scalar.
     */
    divScalar: (k: number) => void;
    /**
     * Checks if each component of this Vec2 is exactly equal to that of the other Vec2.
     */
    equals: (other: Vec2Like) => boolean;
    /**
     * Checks if each component of this Vec2 is exactly equal to the specified scalar.
     */
    equalsScalar: (k: number) => boolean;
    /**
     * Checks if each component of this Vec2 is approximately equal to that of the other Vec2.
     */
    epsilonEquals: (other: Vec2Like, e: number) => boolean;
    /**
     * Checks if each component of this Vec2 is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar: (k: number, e: number) => boolean;
    /**
     * Returns a string representation of this Vec2.
     */
    toString: () => string;

    /**
     * The X component of the current Vec2.
     */
    get x() {
        return this.data[this.dataPosition + 0];
    }

    /**
     * The X component of the current Vec2.
     */
    set x(value: number) {
        this.data[this.dataPosition + 0] = value;
    }

    /**
     * The Y component of the current Vec2.
     */
    get y() {
        return this.data[this.dataPosition + 1];
    }

    /**
     * The Y component of the current Vec2.
     */
    set y(value: number) {
        this.data[this.dataPosition + 1] = value;
    }

    /**
     * Gets the number of properties in a Vec2, namely 2.
     */
    structLength() {
        return 2;
    }

    /**
     * Gets the components of the Vec2 at the specified position of this buffer.
     */
    aget(position: number, dst?: Vec2Like) {
        if (dst === void 0){ dst = new Vec2()};
        let dataPos = position * this.structLength();
        dst.x = this.data[dataPos++];
        dst.y = this.data[dataPos++];
        return dst;
    }

    /**
     * Gets the components of the current Vec2, then moves to the next position of this buffer.
     */
    rget(dst?: Vec2Like) {
        if (dst === void 0){ dst = new Vec2()};
        dst.x = this.data[this.dataPosition++];
        dst.y = this.data[this.dataPosition++];
        return dst;
    }

    /**
     * Sets each component of the Vec2 at the specified position to that of the src Vec2.
     */
    aset(position: number, src: Vec2Like) {
        let dataPos = position * this.structLength();
        this.data[dataPos++] = src.x;
        this.data[dataPos++] = src.y;
    }

    /**
     * Sets each component of the Vec2 at the specified position.
     */
    aset$(position: number, x: number, y: number) {
        let dataPos = position * this.structLength();
        this.data[dataPos++] = x;
        this.data[dataPos++] = y;
    }

    /**
     * Sets each component of the current Vec2 to that of the src Vec2, then moves to the next position of this buffer.
     */
    rset(src: Vec2Like) {
        this.data[this.dataPosition++] = src.x;
        this.data[this.dataPosition++] = src.y;
    }

    /**
     * Sets each component of the current Vec2, then moves to the next position of this buffer.
     */
    rset$(x: number, y: number) {
        this.data[this.dataPosition++] = x;
        this.data[this.dataPosition++] = y;
    }
}

applyMixins(Vec2Buffer, Vec2);